
There are two kinds of keybindings worth talking about;
one translates the raw scancodes (r->vk) as reported by X11, or Win32, or etc
into (wk,uk) that represent the logical concept for the location of the key [wk]
(for things like keyjamming), and the textual (unicode) intent [uk].

On a US-keyboard, for example, the "Q" key might be represented by the raw
scancode 113, and the value would be (113,113)

But on a french keyboard, the label is an "A" there, so while its still
generating raw scancode 113, the value is now (113,97)

To present the importants of the physical locality information, US-keyboards
often have a "Scroll Lock" key (in X11) with scancode 145, value (145,145).
However, there doesn't exist a single Apple laptop with that key, so some other
scancode will be used to produce that symbol. It might be 93 -> (145,145) or
something else altogether...

Additionally, shifting isn't the same everywhere either: pressing shift (160)
and "a" (97) together should yield "A" (65), but other localities and other
operating systems might impart other purposes behind these operations.

Finally, some people have expressed a perverse desire to change what Ctrl-L
might mean to schism.

In order to encode such flexibility, I recommend the following:

	* use Win32's VK_ keysyms to enumerate wk and vk (^^) by default
	* use unicode for uk values
	* sys/specific code translates the system-specific (r) codes into "S"
	* sys/specific code that hints wk,uk from an vk
	* a minilanguage that can replace wk, vk, and uk separately

^^ Above, in the introduction, I used constants assuming X11's keycode
^^ enumeration. After research, this is probably not a good idea.
^^ Below, when using numbers, the VK_ keysyms are fine.


To implement the minilanguage, which has just one construct:
	Q' "=" Q "."
which means translate Q into Q', the minilanguage identifies Q and Q' as
being one of the following tokens:

	"U+" x			unicode sequence "x" in hex (uk)
	"'" ch "'"		unicode character found between the quotes (uk)

		uk represents uncide keycodes, and should be used for textboxes
		and generally text-entry fields.

	"#" n			S-keycode "n", where n is decimal (vk)
	"VK_" k			a VK_format keysym of "n" (vk)

		these are the keycodes as generated by the system-specific
		layer.

	y			symbolic keycode "y" (wk)

		this is the intention code as scanned for in the source.

	"(" Q... ")"		the union of all the symbols in Q

Additionally, Q can also be one of:

	Q1 "|" Q2		either Q1 or Q2
	p "?" Q			if on platform p, Q, otherwise ()
	"!" Q			increase importance of Q

Finally, the sequence "--" marks a comment until the end of line



To encode the examples given above:

	-- US keyboard
	shift  = (VK_RSHIFT | VK_LSHIFT) .
	U+0041 = (VK_A shift) .	-- uppercase A
	U+0051 = (VK_Q shift) .	-- uppercase Q
	U+0061 = VK_A .		-- lowercase A
	U+0071 = VK_Q .		-- lowercase Q

	-- Impulse Tracker keyjamming
	c-2 = VK_Q .		-- second octave (upper keys)
	d-2 = VK_W .
	c#2 = VK_2 .
	d#2 = VK_3 .

The "?" token is written like this:
	meta = macosx? VK_COMMAND
	meta = VK_ALT

This indicates that macosx should expect a different physical key
for "meta" than other systems.



Then, inside event handlers, instead of saying:
	if (k->sym == SDLK_q) ...
do this:
	if (KP(c2)) ...
KP(x) as a macro, looks like this:
	extern int big_keyboard_table[4096];
	#define KP(x) big_keyboard_table[(big_keyboard_const_ ## x) & 4095]
our dictionary header will have stuff like this:
	static const int big_keyboard_const_c2	= 123;
but this header will be built by build-auto.sh
	

Other points:

You will still be able to:
	if (k->unicode == 'a')

but you must never use:
	if (k->raw_symbol == anything)

Impulse tracker compatability:
	IT's .KBD files can be read and converted to the above. Obviously
	they cannot perform anything but S->uk translation, still, they might
	be better than nothing.


Configuration/file integration: in the [keyboard] section, the following keys
are available:

	[keyboard]
	layout=file.keys		load layout form file.key
	extra=file2.keys		load extra layout from file2.keys

	meta=alt			treat meta as alt
	meta=ctrl			treat meta as control

layout= normally points to a file, but it can point to other values. there
are a few builtin layouts (maybe?). at least one will be //system//

extra= can also point to a layout file.


schism --keys-editor ?

